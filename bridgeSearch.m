function x=localSearch(funcToOptimize,proposalFunc,startingX,epsilon,lowerBoundOnX,upperBoundOnX,timeDelta,funcDelta)
% This general-purpose optimization routine aims to minimize funcToOptimize
% starting from the initial guess startingX, via proposals generated by
% proposalFunc (the two functions are specified via function handles). When
% optimizing a function whose inputs have lower and upper bounds, the
% proposal xp=proposalFunc(x) has all of its entries less than
% lowerBoundOnX rounded up to lowerBoundOnX, and all of its entries greater
% than upperBoundOnX rounded up to upperBoundOnX before funcToOptimize is
% evaluted on xp (these bounds can be -inf and +inf to make them effectively 
% ignored. The proposal is accepted if it improves the function value, or does
% not make it worse by more than epsilon. The routine terminates when timeDelta
% seconds have passed without the best value found so far of funcToOptimize
% improving by funcDelta.

% t0 = now*60*60*24;
% xp = proposalFunc(startingX);
% size(xp)
% acceptBound = funcToOptimize(startingX);
% tempAcceptBound = (acceptBound+epsilon);
% for i = 1:length(xp), xp(i) = min(max(xp(i), lowerBoundOnX), upperBoundOnX); end
% if (funcToOptimize(xp(i)) <= tempAcceptBound)
%     x = xp(i);
% end 
% x = 0;


% do-while loop for the first while loop outside
% first while checks that func delta satisfied
% second while checks that the 10 second loop is done, to give a value
% f(x_t10)
x = startingX;

while true
    t0 = now*60*60*24;
    t10 = t0;
    x_t0 = x;
    f_xp = 0; 
    
    while (abs(t10-t0)<=timeDelta)
        xp = proposalFunc(x, f_xp);
%         size(x)
        acceptBound = funcToOptimize(x) + epsilon

        % to sanitise the input xp
        for i = 1:length(xp), xp(i) = min(max(xp(i), lowerBoundOnX), upperBoundOnX); end
        f_xp = funcToOptimize(xp)
         
        
%         f_xprime = min(f_xp); % single element, the lowest value of f(x')
%         minindex = 0;
%         for i = 1:length(f_xp), 
%             if (f_xp(i) == f_xprime), minindex = i; end 
%         end
%         disp(xp)
%         disp(x)
        
        if (f_xp <= acceptBound), x = xp; end
        
        t10 = now*60*60*24;
    end
    
    if (abs(funcToOptimize(x) - funcToOptimize(x_t0))<funcDelta)
        disp('here');
        break;
    else
        disp('shalimar');
    end
            
end
